/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "scribe_types.h"

#include <thrift/lib/cpp/Reflection.h>
#include <algorithm>
#include <string.h>

namespace Tleveldb {

int _kResultCodeValues[] = {
  OK,
  TRY_LATER,
  ERROR_DECOMPRESS
};

const char* _kResultCodeNames[] = {
  "OK",
  "TRY_LATER",
  "ERROR_DECOMPRESS"
};

const std::map<int, const char*> _ResultCode_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kResultCodeValues, _kResultCodeNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _ResultCode_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kResultCodeValues, _kResultCodeNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraits< ::Tleveldb::ResultCode>::findName( ::Tleveldb::ResultCode value) {
return findName( ::Tleveldb::_ResultCode_VALUES_TO_NAMES, value);
}

template<>
bool TEnumTraits< ::Tleveldb::ResultCode>::findValue(const char* name,  ::Tleveldb::ResultCode* out) {
return findValue( ::Tleveldb::_ResultCode_NAMES_TO_VALUES, name, out);
}
}} // apache::thrift

namespace Tleveldb {
// Reflection initializer for struct scribe.SourceInfo
namespace {
void reflectionInitializer_16557823557777806572(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 16557823557777806572U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct scribe.SourceInfo";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "host";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "port";
    dt.fields[2] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "timestamp";
    dt.fields[3] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t SourceInfo::_reflection_id;
void SourceInfo::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_16557823557777806572(schema);
}
uint32_t SourceInfo::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SourceInfo::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SourceInfo");
  xfer += oprot->writeFieldBegin("host", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->host);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("port", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("timestamp", apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SourceInfo &a, SourceInfo &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for map<string, string>
namespace {
void reflectionInitializer_9246346592659763371(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 9246346592659763371U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "map<string, string>";
  dt.__isset.mapKeyType = true;
  dt.mapKeyType = 1U;
  dt.__isset.valueType = true;
  dt.valueType = 1U;
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

// Reflection initializer for struct scribe.LogEntry
namespace {
void reflectionInitializer_15053466696968532300(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 15053466696968532300U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_16557823557777806572(schema);  // struct scribe.SourceInfo
  reflectionInitializer_9246346592659763371(schema);  // map<string, string>
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct scribe.LogEntry";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "category";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "message";
    dt.fields[2] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = false;
    f.type = 9246346592659763371U;
    f.name = "metadata";
    dt.fields[3] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = false;
    f.type = 5U;
    f.name = "checksum";
    dt.fields[4] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = false;
    f.type = 16557823557777806572U;
    f.name = "source";
    dt.fields[5] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = false;
    f.type = 5U;
    f.name = "bucket";
    dt.fields[6] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t LogEntry::_reflection_id;
void LogEntry::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_15053466696968532300(schema);
}
uint32_t LogEntry::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size0;
            apache::thrift::protocol::TType _ktype1;
            apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->metadata[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->source.read(iprot);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LogEntry::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LogEntry");
  xfer += oprot->writeFieldBegin("category", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->category);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("message", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->message);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRING, this->metadata.size());
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->metadata.begin(); _iter7 != this->metadata.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->source.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucket) {
    xfer += oprot->writeFieldBegin("bucket", apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->bucket);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LogEntry &a, LogEntry &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.category, b.category);
  swap(a.message, b.message);
  swap(a.metadata, b.metadata);
  swap(a.checksum, b.checksum);
  swap(a.source, b.source);
  swap(a.bucket, b.bucket);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for list<struct scribe.LogEntry>
namespace {
void reflectionInitializer_10251729064312664553(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 10251729064312664553U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_15053466696968532300(schema);  // struct scribe.LogEntry
  ::apache::thrift::reflection::DataType dt;
  dt.name = "list<struct scribe.LogEntry>";
  dt.__isset.valueType = true;
  dt.valueType = 15053466696968532300U;
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

// Reflection initializer for struct scribe.MessageList
namespace {
void reflectionInitializer_5674270912483072844(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 5674270912483072844U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_10251729064312664553(schema);  // list<struct scribe.LogEntry>
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct scribe.MessageList";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 10251729064312664553U;
    f.name = "messages";
    dt.fields[1] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t MessageList::_reflection_id;
void MessageList::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_5674270912483072844(schema);
}
uint32_t MessageList::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->messages.clear();
            uint32_t _size8;
            apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->messages.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->messages[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.messages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MessageList::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MessageList");
  xfer += oprot->writeFieldBegin("messages", apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->messages.size());
    std::vector<LogEntry> ::const_iterator _iter13;
    for (_iter13 = this->messages.begin(); _iter13 != this->messages.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageList &a, MessageList &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.messages, b.messages);
  swap(a.__isset, b.__isset);
}

} // namespace
