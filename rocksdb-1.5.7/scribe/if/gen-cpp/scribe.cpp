/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "scribe.h"
#include "folly/ScopeGuard.h"

namespace Tleveldb {

uint32_t scribe_Log_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->messages.clear();
            uint32_t _size14;
            apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->messages.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->messages[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.messages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_Log_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_Log_args");
  xfer += oprot->writeFieldBegin("messages", apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->messages.size());
    std::vector<LogEntry> ::const_iterator _iter19;
    for (_iter19 = this->messages.begin(); _iter19 != this->messages.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_Log_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_Log_pargs");
  xfer += oprot->writeFieldBegin("messages", apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, (*(this->messages)).size());
    std::vector<LogEntry> ::const_iterator _iter20;
    for (_iter20 = (*(this->messages)).begin(); _iter20 != (*(this->messages)).end(); ++_iter20)
    {
      xfer += (*_iter20).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_Log_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->success = (ResultCode)ecast21;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_Log_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("scribe_Log_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_Log_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          (*(this->success)) = (ResultCode)ecast22;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogMulti_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->messages.clear();
            uint32_t _size23;
            apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->messages.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->messages[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.messages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogMulti_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_LogMulti_args");
  xfer += oprot->writeFieldBegin("messages", apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->messages.size());
    std::vector<LogEntry> ::const_iterator _iter28;
    for (_iter28 = this->messages.begin(); _iter28 != this->messages.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogMulti_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_LogMulti_pargs");
  xfer += oprot->writeFieldBegin("messages", apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, (*(this->messages)).size());
    std::vector<LogEntry> ::const_iterator _iter29;
    for (_iter29 = (*(this->messages)).begin(); _iter29 != (*(this->messages)).end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogMulti_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size30;
            apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->success.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              int32_t ecast35;
              xfer += iprot->readI32(ecast35);
              this->success[_i34] = (ResultCode)ecast35;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogMulti_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("scribe_LogMulti_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->success.size());
      std::vector<ResultCode> ::const_iterator _iter36;
      for (_iter36 = this->success.begin(); _iter36 != this->success.end(); ++_iter36)
      {
        xfer += oprot->writeI32((int32_t)(*_iter36));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogMulti_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size37;
            apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            (*(this->success)).resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              int32_t ecast42;
              xfer += iprot->readI32(ecast42);
              (*(this->success))[_i41] = (ResultCode)ecast42;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogCompressedMsg_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->compressedMessages);
          this->__isset.compressedMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogCompressedMsg_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_LogCompressedMsg_args");
  xfer += oprot->writeFieldBegin("compressedMessages", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->compressedMessages);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogCompressedMsg_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("scribe_LogCompressedMsg_pargs");
  xfer += oprot->writeFieldBegin("compressedMessages", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->compressedMessages)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogCompressedMsg_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast43;
          xfer += iprot->readI32(ecast43);
          this->success = (ResultCode)ecast43;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scribe_LogCompressedMsg_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("scribe_LogCompressedMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t scribe_LogCompressedMsg_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          (*(this->success)) = (ResultCode)ecast44;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

int32_t scribeClient::getNextSendSequenceId()
{
  return nextSendSequenceId_++;
}

int32_t scribeClient::getNextRecvSequenceId()
{
  return nextRecvSequenceId_++;
}

ResultCode scribeClient::Log(const std::vector<LogEntry> & messages)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("scribe.Log", NULL);

  try {
    send_Log(messages);
    return recv_Log();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "scribe.Log");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "scribe.Log");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void scribeClient::send_Log(const std::vector<LogEntry> & messages)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "scribe.Log");
  oprot_->writeMessageBegin("Log", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  scribe_Log_pargs args;
  args.messages = &messages;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes45 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "scribe.Log", _bytes45);
  return;
}

ResultCode scribeClient::recv_Log()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "scribe.Log");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Log") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  ResultCode _return;
  scribe_Log_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "scribe.Log", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Log failed: unknown result");
}

void scribeClient::LogMulti(std::vector<ResultCode> & _return, const std::vector<LogEntry> & messages)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("scribe.LogMulti", NULL);

  try {
    send_LogMulti(messages);
    recv_LogMulti(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "scribe.LogMulti");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "scribe.LogMulti");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void scribeClient::send_LogMulti(const std::vector<LogEntry> & messages)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "scribe.LogMulti");
  oprot_->writeMessageBegin("LogMulti", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  scribe_LogMulti_pargs args;
  args.messages = &messages;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes46 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "scribe.LogMulti", _bytes46);
  return;
}

void scribeClient::recv_LogMulti(std::vector<ResultCode> & _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "scribe.LogMulti");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("LogMulti") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  scribe_LogMulti_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "scribe.LogMulti", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "LogMulti failed: unknown result");
}

ResultCode scribeClient::LogCompressedMsg(const std::string& compressedMessages)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("scribe.LogCompressedMsg", NULL);

  try {
    send_LogCompressedMsg(compressedMessages);
    return recv_LogCompressedMsg();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "scribe.LogCompressedMsg");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "scribe.LogCompressedMsg");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void scribeClient::send_LogCompressedMsg(const std::string& compressedMessages)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "scribe.LogCompressedMsg");
  oprot_->writeMessageBegin("LogCompressedMsg", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  scribe_LogCompressedMsg_pargs args;
  args.compressedMessages = &compressedMessages;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes47 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "scribe.LogCompressedMsg", _bytes47);
  return;
}

ResultCode scribeClient::recv_LogCompressedMsg()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "scribe.LogCompressedMsg");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("LogCompressedMsg") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  ResultCode _return;
  scribe_LogCompressedMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "scribe.LogCompressedMsg", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "LogCompressedMsg failed: unknown result");
}

bool scribeProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    apache::thrift::TApplicationException x(apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  const ProcessFunction& pf = pfn->second;
  (this->*pf)(seqid, iprot, oprot, connectionContext);
  return true;
}

void scribeProcessor::process_Log(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("scribe.Log", connectionContext));

  this->preRead(ctx.get(), "scribe.Log");
  scribe_Log_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "scribe.Log", bytes);

  scribe_Log_result result;
  try {
    result.success = iface_->Log(args.messages);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "scribe.Log");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Log", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "scribe.Log");
  oprot->writeMessageBegin("Log", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "scribe.Log", bytes);

}

void scribeProcessor::process_LogMulti(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("scribe.LogMulti", connectionContext));

  this->preRead(ctx.get(), "scribe.LogMulti");
  scribe_LogMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "scribe.LogMulti", bytes);

  scribe_LogMulti_result result;
  try {
    iface_->LogMulti(result.success, args.messages);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "scribe.LogMulti");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("LogMulti", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "scribe.LogMulti");
  oprot->writeMessageBegin("LogMulti", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "scribe.LogMulti", bytes);

}

void scribeProcessor::process_LogCompressedMsg(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("scribe.LogCompressedMsg", connectionContext));

  this->preRead(ctx.get(), "scribe.LogCompressedMsg");
  scribe_LogCompressedMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "scribe.LogCompressedMsg", bytes);

  scribe_LogCompressedMsg_result result;
  try {
    result.success = iface_->LogCompressedMsg(args.compressedMessages);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "scribe.LogCompressedMsg");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("LogCompressedMsg", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "scribe.LogCompressedMsg");
  oprot->writeMessageBegin("LogCompressedMsg", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "scribe.LogCompressedMsg", bytes);

}

::boost::shared_ptr< ::apache::thrift::TProcessor > scribeProcessorFactory::getProcessor(::apache::thrift::server::TConnectionContext* ctx) {
  ::apache::thrift::ReleaseHandler< scribeIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< scribeIf > handler(handlerFactory_->getHandler(ctx), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new scribeProcessor(handler));
  return processor;
}
} // namespace
