/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "leveldb_types.h"

#include <thrift/lib/cpp/Reflection.h>
#include <algorithm>
#include <string.h>

namespace Tleveldb {

int _kCompressionTypeValues[] = {
  kNoCompression,
  kSnappyCompression
};

const char* _kCompressionTypeNames[] = {
  "kNoCompression",
  "kSnappyCompression"
};

const std::map<int, const char*> _CompressionType_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(2, _kCompressionTypeValues, _kCompressionTypeNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _CompressionType_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(2, _kCompressionTypeValues, _kCompressionTypeNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraits< ::Tleveldb::CompressionType>::findName( ::Tleveldb::CompressionType value) {
return findName( ::Tleveldb::_CompressionType_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraits< ::Tleveldb::CompressionType>::findValue(const char* name,  ::Tleveldb::CompressionType* out) {
return findValue( ::Tleveldb::_CompressionType_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace Tleveldb {
int _kCodeValues[] = {
  kOk,
  kNotFound,
  kCorruption,
  kNotSupported,
  kInvalidArgument,
  kIOError,
  kEnd
};

const char* _kCodeNames[] = {
  "kOk",
  "kNotFound",
  "kCorruption",
  "kNotSupported",
  "kInvalidArgument",
  "kIOError",
  "kEnd"
};

const std::map<int, const char*> _Code_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(7, _kCodeValues, _kCodeNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _Code_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(7, _kCodeValues, _kCodeNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraits< ::Tleveldb::Code>::findName( ::Tleveldb::Code value) {
return findName( ::Tleveldb::_Code_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraits< ::Tleveldb::Code>::findValue(const char* name,  ::Tleveldb::Code* out) {
return findValue( ::Tleveldb::_Code_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace Tleveldb {
int _kIteratorTypeValues[] = {
  seekToFirst,
  seekToLast,
  seekToKey
};

const char* _kIteratorTypeNames[] = {
  "seekToFirst",
  "seekToLast",
  "seekToKey"
};

const std::map<int, const char*> _IteratorType_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kIteratorTypeValues, _kIteratorTypeNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _IteratorType_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kIteratorTypeValues, _kIteratorTypeNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraits< ::Tleveldb::IteratorType>::findName( ::Tleveldb::IteratorType value) {
return findName( ::Tleveldb::_IteratorType_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraits< ::Tleveldb::IteratorType>::findValue(const char* name,  ::Tleveldb::IteratorType* out) {
return findValue( ::Tleveldb::_IteratorType_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace Tleveldb {
int _kAssocVisibilityValues[] = {
  VISIBLE,
  DELETED,
  UNUSED1,
  HIDDEN,
  UNUSED2,
  HARD_DELETE
};

const char* _kAssocVisibilityNames[] = {
  "VISIBLE",
  "DELETED",
  "UNUSED1",
  "HIDDEN",
  "UNUSED2",
  "HARD_DELETE"
};

const std::map<int, const char*> _AssocVisibility_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(6, _kAssocVisibilityValues, _kAssocVisibilityNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _AssocVisibility_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(6, _kAssocVisibilityValues, _kAssocVisibilityNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraits< ::Tleveldb::AssocVisibility>::findName( ::Tleveldb::AssocVisibility value) {
return findName( ::Tleveldb::_AssocVisibility_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraits< ::Tleveldb::AssocVisibility>::findValue(const char* name,  ::Tleveldb::AssocVisibility* out) {
return findValue( ::Tleveldb::_AssocVisibility_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace Tleveldb {
// Reflection initializer for struct leveldb.Slice
namespace {
void reflectionInitializer_2199896239461470156(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 2199896239461470156U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.Slice";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "data";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "size";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t Slice::_reflection_id;
void Slice::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_2199896239461470156(schema);
}
uint32_t Slice::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Slice::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Slice");
  xfer += oprot->writeFieldBegin("data", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("size", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Slice &a, Slice &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.data, b.data);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.Range
namespace {
void reflectionInitializer_6170219570187881516(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 6170219570187881516U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_2199896239461470156(schema);  // struct leveldb.Slice
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.Range";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2199896239461470156U;
    f.name = "start";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2199896239461470156U;
    f.name = "limit";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t Range::_reflection_id;
void Range::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_6170219570187881516(schema);
}
uint32_t Range::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->limit.read(iprot);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Range::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Range");
  xfer += oprot->writeFieldBegin("start", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("limit", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->limit.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Range &a, Range &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.start, b.start);
  swap(a.limit, b.limit);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for enum leveldb.CompressionType
namespace {
void reflectionInitializer_13050266898380890824(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 13050266898380890824U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "enum leveldb.CompressionType";
  dt.__isset.enumValues = true;
  dt.enumValues["kNoCompression"] = 0;
  dt.enumValues["kSnappyCompression"] = 1;
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

// Reflection initializer for struct leveldb.DBOptions
namespace {
void reflectionInitializer_6731746507948871532(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 6731746507948871532U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_13050266898380890824(schema);  // enum leveldb.CompressionType
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.DBOptions";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "create_if_missing";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "error_if_exists";
    dt.fields[2] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "write_buffer_size";
    dt.fields[3] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "max_open_files";
    dt.fields[4] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "block_size";
    dt.fields[5] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "block_restart_interval";
    dt.fields[6] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13050266898380890824U;
    f.name = "compression";
    dt.fields[7] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "num_levels";
    dt.fields[8] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "level0_file_num_compaction_trigger";
    dt.fields[9] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "level0_slowdown_writes_trigger";
    dt.fields[10] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "level0_stop_writes_trigger";
    dt.fields[11] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "target_file_size_base";
    dt.fields[12] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "target_file_size_multiplier";
    dt.fields[13] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "max_bytes_for_level_base";
    dt.fields[14] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "max_bytes_for_level_multiplier";
    dt.fields[15] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 5U;
    f.name = "max_grandparent_overlap_factor";
    dt.fields[16] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "disableDataSync";
    dt.fields[17] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t DBOptions::_reflection_id;
void DBOptions::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_6731746507948871532(schema);
}
uint32_t DBOptions::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_if_missing);
          this->__isset.create_if_missing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->error_if_exists);
          this->__isset.error_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->write_buffer_size);
          this->__isset.write_buffer_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_open_files);
          this->__isset.max_open_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_size);
          this->__isset.block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_restart_interval);
          this->__isset.block_restart_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->compression = (CompressionType)ecast0;
          this->__isset.compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_levels);
          this->__isset.num_levels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level0_file_num_compaction_trigger);
          this->__isset.level0_file_num_compaction_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level0_slowdown_writes_trigger);
          this->__isset.level0_slowdown_writes_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level0_stop_writes_trigger);
          this->__isset.level0_stop_writes_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target_file_size_base);
          this->__isset.target_file_size_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target_file_size_multiplier);
          this->__isset.target_file_size_multiplier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_bytes_for_level_base);
          this->__isset.max_bytes_for_level_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_bytes_for_level_multiplier);
          this->__isset.max_bytes_for_level_multiplier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_grandparent_overlap_factor);
          this->__isset.max_grandparent_overlap_factor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disableDataSync);
          this->__isset.disableDataSync = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DBOptions::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DBOptions");
  xfer += oprot->writeFieldBegin("create_if_missing", apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_if_missing);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("error_if_exists", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->error_if_exists);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("write_buffer_size", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->write_buffer_size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max_open_files", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->max_open_files);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("block_size", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->block_size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("block_restart_interval", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->block_restart_interval);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("compression", apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->compression);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("num_levels", apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->num_levels);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("level0_file_num_compaction_trigger", apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->level0_file_num_compaction_trigger);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("level0_slowdown_writes_trigger", apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->level0_slowdown_writes_trigger);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("level0_stop_writes_trigger", apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->level0_stop_writes_trigger);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("target_file_size_base", apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->target_file_size_base);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("target_file_size_multiplier", apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->target_file_size_multiplier);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max_bytes_for_level_base", apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->max_bytes_for_level_base);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max_bytes_for_level_multiplier", apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->max_bytes_for_level_multiplier);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max_grandparent_overlap_factor", apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->max_grandparent_overlap_factor);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("disableDataSync", apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->disableDataSync);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBOptions &a, DBOptions &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.create_if_missing, b.create_if_missing);
  swap(a.error_if_exists, b.error_if_exists);
  swap(a.write_buffer_size, b.write_buffer_size);
  swap(a.max_open_files, b.max_open_files);
  swap(a.block_size, b.block_size);
  swap(a.block_restart_interval, b.block_restart_interval);
  swap(a.compression, b.compression);
  swap(a.num_levels, b.num_levels);
  swap(a.level0_file_num_compaction_trigger, b.level0_file_num_compaction_trigger);
  swap(a.level0_slowdown_writes_trigger, b.level0_slowdown_writes_trigger);
  swap(a.level0_stop_writes_trigger, b.level0_stop_writes_trigger);
  swap(a.target_file_size_base, b.target_file_size_base);
  swap(a.target_file_size_multiplier, b.target_file_size_multiplier);
  swap(a.max_bytes_for_level_base, b.max_bytes_for_level_base);
  swap(a.max_bytes_for_level_multiplier, b.max_bytes_for_level_multiplier);
  swap(a.max_grandparent_overlap_factor, b.max_grandparent_overlap_factor);
  swap(a.disableDataSync, b.disableDataSync);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.WriteOptions
namespace {
void reflectionInitializer_8830325115029814540(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 8830325115029814540U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.WriteOptions";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "sync";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "disableWAL";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t WriteOptions::_reflection_id;
void WriteOptions::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_8830325115029814540(schema);
}
uint32_t WriteOptions::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sync);
          this->__isset.sync = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disableWAL);
          this->__isset.disableWAL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriteOptions::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WriteOptions");
  xfer += oprot->writeFieldBegin("sync", apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->sync);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("disableWAL", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->disableWAL);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteOptions &a, WriteOptions &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.sync, b.sync);
  swap(a.disableWAL, b.disableWAL);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.Snapshot
namespace {
void reflectionInitializer_15670548806217660204(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 15670548806217660204U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.Snapshot";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "snapshotid";
    dt.fields[1] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t Snapshot::_reflection_id;
void Snapshot::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_15670548806217660204(schema);
}
uint32_t Snapshot::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->snapshotid);
          this->__isset.snapshotid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Snapshot::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Snapshot");
  xfer += oprot->writeFieldBegin("snapshotid", apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->snapshotid);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Snapshot &a, Snapshot &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.snapshotid, b.snapshotid);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.ReadOptions
namespace {
void reflectionInitializer_1092669993626789804(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 1092669993626789804U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_15670548806217660204(schema);  // struct leveldb.Snapshot
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.ReadOptions";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "verify_checksums";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2U;
    f.name = "fill_cache";
    dt.fields[2] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 15670548806217660204U;
    f.name = "snapshot";
    dt.fields[3] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t ReadOptions::_reflection_id;
void ReadOptions::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_1092669993626789804(schema);
}
uint32_t ReadOptions::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->verify_checksums);
          this->__isset.verify_checksums = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fill_cache);
          this->__isset.fill_cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot.read(iprot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReadOptions::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReadOptions");
  xfer += oprot->writeFieldBegin("verify_checksums", apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->verify_checksums);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fill_cache", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->fill_cache);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("snapshot", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->snapshot.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadOptions &a, ReadOptions &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.verify_checksums, b.verify_checksums);
  swap(a.fill_cache, b.fill_cache);
  swap(a.snapshot, b.snapshot);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.DBHandle
namespace {
void reflectionInitializer_8973827971994157004(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 8973827971994157004U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.DBHandle";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "dbname";
    dt.fields[1] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t DBHandle::_reflection_id;
void DBHandle::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_8973827971994157004(schema);
}
uint32_t DBHandle::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DBHandle::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DBHandle");
  xfer += oprot->writeFieldBegin("dbname", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->dbname);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBHandle &a, DBHandle &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.dbname, b.dbname);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.Iterator
namespace {
void reflectionInitializer_11184146435197093740(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 11184146435197093740U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.Iterator";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "iteratorid";
    dt.fields[1] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t Iterator::_reflection_id;
void Iterator::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_11184146435197093740(schema);
}
uint32_t Iterator::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iteratorid);
          this->__isset.iteratorid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Iterator::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Iterator");
  xfer += oprot->writeFieldBegin("iteratorid", apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->iteratorid);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Iterator &a, Iterator &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.iteratorid, b.iteratorid);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.kv
namespace {
void reflectionInitializer_16082992224095104076(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 16082992224095104076U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_2199896239461470156(schema);  // struct leveldb.Slice
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.kv";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2199896239461470156U;
    f.name = "key";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2199896239461470156U;
    f.name = "value";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t kv::_reflection_id;
void kv::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_16082992224095104076(schema);
}
uint32_t kv::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kv::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("kv");
  xfer += oprot->writeFieldBegin("key", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kv &a, kv &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for enum leveldb.Code
namespace {
void reflectionInitializer_13230961887206242376(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 13230961887206242376U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "enum leveldb.Code";
  dt.__isset.enumValues = true;
  dt.enumValues["kCorruption"] = 2;
  dt.enumValues["kEnd"] = 6;
  dt.enumValues["kIOError"] = 5;
  dt.enumValues["kInvalidArgument"] = 4;
  dt.enumValues["kNotFound"] = 1;
  dt.enumValues["kNotSupported"] = 3;
  dt.enumValues["kOk"] = 0;
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

// Reflection initializer for struct leveldb.ResultItem
namespace {
void reflectionInitializer_13211316281207238796(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 13211316281207238796U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_13230961887206242376(schema);  // enum leveldb.Code
  reflectionInitializer_2199896239461470156(schema);  // struct leveldb.Slice
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.ResultItem";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13230961887206242376U;
    f.name = "status";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 2199896239461470156U;
    f.name = "value";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t ResultItem::_reflection_id;
void ResultItem::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_13211316281207238796(schema);
}
uint32_t ResultItem::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->status = (Code)ecast1;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResultItem::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultItem");
  xfer += oprot->writeFieldBegin("status", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultItem &a, ResultItem &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.ResultPair
namespace {
void reflectionInitializer_14875242256166808460(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 14875242256166808460U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_13230961887206242376(schema);  // enum leveldb.Code
  reflectionInitializer_16082992224095104076(schema);  // struct leveldb.kv
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.ResultPair";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13230961887206242376U;
    f.name = "status";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 16082992224095104076U;
    f.name = "keyvalue";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t ResultPair::_reflection_id;
void ResultPair::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_14875242256166808460(schema);
}
uint32_t ResultPair::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->status = (Code)ecast2;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyvalue.read(iprot);
          this->__isset.keyvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResultPair::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultPair");
  xfer += oprot->writeFieldBegin("status", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("keyvalue", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->keyvalue.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultPair &a, ResultPair &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.status, b.status);
  swap(a.keyvalue, b.keyvalue);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.ResultSnapshot
namespace {
void reflectionInitializer_16627180600575569004(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 16627180600575569004U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_13230961887206242376(schema);  // enum leveldb.Code
  reflectionInitializer_15670548806217660204(schema);  // struct leveldb.Snapshot
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.ResultSnapshot";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13230961887206242376U;
    f.name = "status";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 15670548806217660204U;
    f.name = "snapshot";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t ResultSnapshot::_reflection_id;
void ResultSnapshot::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_16627180600575569004(schema);
}
uint32_t ResultSnapshot::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->status = (Code)ecast3;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot.read(iprot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResultSnapshot::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultSnapshot");
  xfer += oprot->writeFieldBegin("status", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("snapshot", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->snapshot.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultSnapshot &a, ResultSnapshot &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.status, b.status);
  swap(a.snapshot, b.snapshot);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.ResultIterator
namespace {
void reflectionInitializer_595886977232564460(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 595886977232564460U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_11184146435197093740(schema);  // struct leveldb.Iterator
  reflectionInitializer_13230961887206242376(schema);  // enum leveldb.Code
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.ResultIterator";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13230961887206242376U;
    f.name = "status";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 11184146435197093740U;
    f.name = "iterator";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t ResultIterator::_reflection_id;
void ResultIterator::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_595886977232564460(schema);
}
uint32_t ResultIterator::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->status = (Code)ecast4;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->iterator.read(iprot);
          this->__isset.iterator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResultIterator::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultIterator");
  xfer += oprot->writeFieldBegin("status", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->iterator.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultIterator &a, ResultIterator &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.status, b.status);
  swap(a.iterator, b.iterator);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.LeveldbException
namespace {
void reflectionInitializer_2551220192341843436(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 2551220192341843436U;
  if (schema.dataTypes.count(id)) return;
  reflectionInitializer_13230961887206242376(schema);  // enum leveldb.Code
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.LeveldbException";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "message";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 13230961887206242376U;
    f.name = "errorCode";
    dt.fields[2] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t LeveldbException::_reflection_id;
void LeveldbException::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_2551220192341843436(schema);
}
uint32_t LeveldbException::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->errorCode = (Code)ecast5;
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeveldbException::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LeveldbException");
  xfer += oprot->writeFieldBegin("message", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->message);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("errorCode", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->errorCode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeveldbException &a, LeveldbException &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.message, b.message);
  swap(a.errorCode, b.errorCode);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.IOError
namespace {
void reflectionInitializer_8460881927871070060(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 8460881927871070060U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.IOError";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "message";
    dt.fields[1] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t IOError::_reflection_id;
void IOError::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_8460881927871070060(schema);
}
uint32_t IOError::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IOError::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IOError");
  xfer += oprot->writeFieldBegin("message", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IOError &a, IOError &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

// Reflection initializer for struct leveldb.TaoAssocGetResult
namespace {
void reflectionInitializer_6301164048086986412(::apache::thrift::reflection::Schema& schema) {
  const uint64_t id = 6301164048086986412U;
  if (schema.dataTypes.count(id)) return;
  ::apache::thrift::reflection::DataType dt;
  dt.name = "struct leveldb.TaoAssocGetResult";
    dt.__isset.fields = true;
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "id2";
    dt.fields[1] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "id1Type";
    dt.fields[2] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "id2Type";
    dt.fields[3] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "time";
    dt.fields[4] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 6U;
    f.name = "dataVersion";
    dt.fields[5] = f;
  }
  {
    ::apache::thrift::reflection::StructField f;
    f.isRequired = true;
    f.type = 1U;
    f.name = "data";
    dt.fields[6] = f;
  }
  schema.dataTypes[id] = dt;
  schema.names[dt.name] = id;
}
}  // namespace

const uint64_t TaoAssocGetResult::_reflection_id;
void TaoAssocGetResult::_reflection_register(::apache::thrift::reflection::Schema& schema) {
  reflectionInitializer_6301164048086986412(schema);
}
uint32_t TaoAssocGetResult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id2);
          this->__isset.id2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id1Type);
          this->__isset.id1Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id2Type);
          this->__isset.id2Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataVersion);
          this->__isset.dataVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaoAssocGetResult::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TaoAssocGetResult");
  xfer += oprot->writeFieldBegin("id2", apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("id1Type", apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id1Type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("id2Type", apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->id2Type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("time", apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dataVersion", apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->dataVersion);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("data", apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaoAssocGetResult &a, TaoAssocGetResult &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.id2, b.id2);
  swap(a.id1Type, b.id1Type);
  swap(a.id2Type, b.id2Type);
  swap(a.time, b.time);
  swap(a.dataVersion, b.dataVersion);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

} // namespace
