/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DB.h"
#include "folly/ScopeGuard.h"

namespace Tleveldb {

uint32_t DB_Open_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dboptions.read(iprot);
          this->__isset.dboptions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Open_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Open_args");
  xfer += oprot->writeFieldBegin("dbname", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->dbname);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dboptions", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->dboptions.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Open_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Open_pargs");
  xfer += oprot->writeFieldBegin("dbname", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->dbname)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dboptions", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->dboptions)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Open_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->se.read(iprot);
          this->__isset.se = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Open_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Open_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.se) {
    xfer += oprot->writeFieldBegin("se", apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->se.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Open_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->se.read(iprot);
          this->__isset.se = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Close_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Close_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Close_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dbname", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->dbname);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Close_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Close_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dbname", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->dbname)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Close_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->success = (Code)ecast6;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Close_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Close_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Close_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          (*(this->success)) = (Code)ecast7;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Put_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyvalue.read(iprot);
          this->__isset.keyvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Put_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Put_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("keyvalue", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->keyvalue.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Put_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Put_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("keyvalue", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->keyvalue)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Put_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->success = (Code)ecast8;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Put_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Put_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Put_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          (*(this->success)) = (Code)ecast9;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Delete_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Delete_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Delete_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Delete_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Delete_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->key)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Delete_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->success = (Code)ecast10;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Delete_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Delete_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Delete_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          (*(this->success)) = (Code)ecast11;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Write_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->batch.clear();
            uint32_t _size12;
            apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->batch.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->batch[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Write_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Write_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("batch", apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->batch.size());
    std::vector<kv> ::const_iterator _iter17;
    for (_iter17 = this->batch.begin(); _iter17 != this->batch.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Write_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Write_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("batch", apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, (*(this->batch)).size());
    std::vector<kv> ::const_iterator _iter18;
    for (_iter18 = (*(this->batch)).begin(); _iter18 != (*(this->batch)).end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Write_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->success = (Code)ecast19;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Write_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Write_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Write_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          (*(this->success)) = (Code)ecast20;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Get_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->inputkey.read(iprot);
          this->__isset.inputkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Get_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Get_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("inputkey", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->inputkey.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Get_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_Get_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("inputkey", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->inputkey)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Get_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_Get_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_Get_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_Get_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_NewIterator_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->iteratorType = (IteratorType)ecast21;
          this->__isset.iteratorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_NewIterator_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_NewIterator_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iteratorType", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->iteratorType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("target", apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_NewIterator_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_NewIterator_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iteratorType", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->iteratorType)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("target", apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->target)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_NewIterator_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_NewIterator_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_NewIterator_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_NewIterator_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_DeleteIterator_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->iterator.read(iprot);
          this->__isset.iterator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_DeleteIterator_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_DeleteIterator_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->iterator.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_DeleteIterator_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_DeleteIterator_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->iterator)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_DeleteIterator_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->success = (Code)ecast22;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_DeleteIterator_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_DeleteIterator_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_DeleteIterator_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          (*(this->success)) = (Code)ecast23;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetNext_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->iterator.read(iprot);
          this->__isset.iterator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetNext_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetNext_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->iterator.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetNext_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetNext_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->iterator)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetNext_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetNext_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_GetNext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetNext_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetPrev_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->iterator.read(iprot);
          this->__isset.iterator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetPrev_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetPrev_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->iterator.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetPrev_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetPrev_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("iterator", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->iterator)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetPrev_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetPrev_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_GetPrev_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetPrev_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetSnapshot_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetSnapshot_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetSnapshot_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetSnapshot_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_GetSnapshot_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetSnapshot_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_GetSnapshot_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_GetSnapshot_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_GetSnapshot_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_ReleaseSnapshot_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot.read(iprot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_ReleaseSnapshot_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_ReleaseSnapshot_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("snapshot", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->snapshot.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_ReleaseSnapshot_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_ReleaseSnapshot_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("snapshot", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->snapshot)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_ReleaseSnapshot_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->success = (Code)ecast24;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_ReleaseSnapshot_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_ReleaseSnapshot_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_ReleaseSnapshot_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          (*(this->success)) = (Code)ecast25;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_CompactRange_args::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->dbhandle.read(iprot);
          this->__isset.dbhandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->endhere.read(iprot);
          this->__isset.endhere = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_CompactRange_args::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_CompactRange_args");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->dbhandle.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("endhere", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->endhere.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_CompactRange_pargs::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DB_CompactRange_pargs");
  xfer += oprot->writeFieldBegin("dbhandle", apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->dbhandle)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->start)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("endhere", apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->endhere)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_CompactRange_result::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->success = (Code)ecast26;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DB_CompactRange_result::write(apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("DB_CompactRange_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t DB_CompactRange_presult::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          (*(this->success)) = (Code)ecast27;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

int32_t DBClient::getNextSendSequenceId()
{
  return nextSendSequenceId_++;
}

int32_t DBClient::getNextRecvSequenceId()
{
  return nextRecvSequenceId_++;
}

void DBClient::Open(DBHandle& _return, const Text& dbname, const DBOptions& dboptions)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Open", NULL);

  try {
    send_Open(dbname, dboptions);
    recv_Open(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Open");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Open");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Open(const Text& dbname, const DBOptions& dboptions)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Open");
  oprot_->writeMessageBegin("Open", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Open_pargs args;
  args.dbname = &dbname;
  args.dboptions = &dboptions;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes28 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Open", _bytes28);
  return;
}

void DBClient::recv_Open(DBHandle& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Open");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Open") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_Open_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Open", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.se) {
    throw result.se;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Open failed: unknown result");
}

Code DBClient::Close(const DBHandle& dbhandle, const Text& dbname)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Close", NULL);

  try {
    send_Close(dbhandle, dbname);
    return recv_Close();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Close");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Close");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Close(const DBHandle& dbhandle, const Text& dbname)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Close");
  oprot_->writeMessageBegin("Close", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Close_pargs args;
  args.dbhandle = &dbhandle;
  args.dbname = &dbname;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes29 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Close", _bytes29);
  return;
}

Code DBClient::recv_Close()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Close");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Close") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_Close_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Close", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Close failed: unknown result");
}

Code DBClient::Put(const DBHandle& dbhandle, const kv& keyvalue, const WriteOptions& options)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Put", NULL);

  try {
    send_Put(dbhandle, keyvalue, options);
    return recv_Put();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Put");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Put");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Put(const DBHandle& dbhandle, const kv& keyvalue, const WriteOptions& options)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Put");
  oprot_->writeMessageBegin("Put", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Put_pargs args;
  args.dbhandle = &dbhandle;
  args.keyvalue = &keyvalue;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes30 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Put", _bytes30);
  return;
}

Code DBClient::recv_Put()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Put");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Put") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_Put_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Put", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Put failed: unknown result");
}

Code DBClient::Delete(const DBHandle& dbhandle, const Slice& key, const WriteOptions& options)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Delete", NULL);

  try {
    send_Delete(dbhandle, key, options);
    return recv_Delete();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Delete");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Delete");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Delete(const DBHandle& dbhandle, const Slice& key, const WriteOptions& options)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Delete");
  oprot_->writeMessageBegin("Delete", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Delete_pargs args;
  args.dbhandle = &dbhandle;
  args.key = &key;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes31 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Delete", _bytes31);
  return;
}

Code DBClient::recv_Delete()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Delete");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Delete") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_Delete_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Delete", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Delete failed: unknown result");
}

Code DBClient::Write(const DBHandle& dbhandle, const std::vector<kv> & batch, const WriteOptions& options)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Write", NULL);

  try {
    send_Write(dbhandle, batch, options);
    return recv_Write();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Write");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Write");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Write(const DBHandle& dbhandle, const std::vector<kv> & batch, const WriteOptions& options)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Write");
  oprot_->writeMessageBegin("Write", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Write_pargs args;
  args.dbhandle = &dbhandle;
  args.batch = &batch;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes32 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Write", _bytes32);
  return;
}

Code DBClient::recv_Write()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Write");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Write") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_Write_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Write", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Write failed: unknown result");
}

void DBClient::Get(ResultItem& _return, const DBHandle& dbhandle, const Slice& inputkey, const ReadOptions& options)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.Get", NULL);

  try {
    send_Get(dbhandle, inputkey, options);
    recv_Get(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.Get");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.Get");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_Get(const DBHandle& dbhandle, const Slice& inputkey, const ReadOptions& options)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.Get");
  oprot_->writeMessageBegin("Get", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_Get_pargs args;
  args.dbhandle = &dbhandle;
  args.inputkey = &inputkey;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes33 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.Get", _bytes33);
  return;
}

void DBClient::recv_Get(ResultItem& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.Get");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("Get") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_Get_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.Get", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "Get failed: unknown result");
}

void DBClient::NewIterator(ResultIterator& _return, const DBHandle& dbhandle, const ReadOptions& options, IteratorType iteratorType, const Slice& target)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.NewIterator", NULL);

  try {
    send_NewIterator(dbhandle, options, iteratorType, target);
    recv_NewIterator(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.NewIterator");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.NewIterator");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_NewIterator(const DBHandle& dbhandle, const ReadOptions& options, IteratorType iteratorType, const Slice& target)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.NewIterator");
  oprot_->writeMessageBegin("NewIterator", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_NewIterator_pargs args;
  args.dbhandle = &dbhandle;
  args.options = &options;
  args.iteratorType = &iteratorType;
  args.target = &target;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes34 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.NewIterator", _bytes34);
  return;
}

void DBClient::recv_NewIterator(ResultIterator& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.NewIterator");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("NewIterator") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_NewIterator_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.NewIterator", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "NewIterator failed: unknown result");
}

Code DBClient::DeleteIterator(const DBHandle& dbhandle, const Iterator& iterator)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.DeleteIterator", NULL);

  try {
    send_DeleteIterator(dbhandle, iterator);
    return recv_DeleteIterator();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.DeleteIterator");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.DeleteIterator");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_DeleteIterator(const DBHandle& dbhandle, const Iterator& iterator)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.DeleteIterator");
  oprot_->writeMessageBegin("DeleteIterator", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_DeleteIterator_pargs args;
  args.dbhandle = &dbhandle;
  args.iterator = &iterator;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes35 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.DeleteIterator", _bytes35);
  return;
}

Code DBClient::recv_DeleteIterator()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.DeleteIterator");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("DeleteIterator") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_DeleteIterator_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.DeleteIterator", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "DeleteIterator failed: unknown result");
}

void DBClient::GetNext(ResultPair& _return, const DBHandle& dbhandle, const Iterator& iterator)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.GetNext", NULL);

  try {
    send_GetNext(dbhandle, iterator);
    recv_GetNext(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.GetNext");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.GetNext");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_GetNext(const DBHandle& dbhandle, const Iterator& iterator)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.GetNext");
  oprot_->writeMessageBegin("GetNext", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_GetNext_pargs args;
  args.dbhandle = &dbhandle;
  args.iterator = &iterator;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes36 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.GetNext", _bytes36);
  return;
}

void DBClient::recv_GetNext(ResultPair& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.GetNext");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("GetNext") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_GetNext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.GetNext", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "GetNext failed: unknown result");
}

void DBClient::GetPrev(ResultPair& _return, const DBHandle& dbhandle, const Iterator& iterator)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.GetPrev", NULL);

  try {
    send_GetPrev(dbhandle, iterator);
    recv_GetPrev(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.GetPrev");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.GetPrev");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_GetPrev(const DBHandle& dbhandle, const Iterator& iterator)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.GetPrev");
  oprot_->writeMessageBegin("GetPrev", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_GetPrev_pargs args;
  args.dbhandle = &dbhandle;
  args.iterator = &iterator;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes37 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.GetPrev", _bytes37);
  return;
}

void DBClient::recv_GetPrev(ResultPair& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.GetPrev");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("GetPrev") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_GetPrev_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.GetPrev", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "GetPrev failed: unknown result");
}

void DBClient::GetSnapshot(ResultSnapshot& _return, const DBHandle& dbhandle)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.GetSnapshot", NULL);

  try {
    send_GetSnapshot(dbhandle);
    recv_GetSnapshot(_return);
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.GetSnapshot");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.GetSnapshot");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_GetSnapshot(const DBHandle& dbhandle)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.GetSnapshot");
  oprot_->writeMessageBegin("GetSnapshot", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_GetSnapshot_pargs args;
  args.dbhandle = &dbhandle;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes38 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.GetSnapshot", _bytes38);
  return;
}

void DBClient::recv_GetSnapshot(ResultSnapshot& _return)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.GetSnapshot");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("GetSnapshot") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  DB_GetSnapshot_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.GetSnapshot", bytes);

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "GetSnapshot failed: unknown result");
}

Code DBClient::ReleaseSnapshot(const DBHandle& dbhandle, const Snapshot& snapshot)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.ReleaseSnapshot", NULL);

  try {
    send_ReleaseSnapshot(dbhandle, snapshot);
    return recv_ReleaseSnapshot();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.ReleaseSnapshot");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.ReleaseSnapshot");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_ReleaseSnapshot(const DBHandle& dbhandle, const Snapshot& snapshot)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.ReleaseSnapshot");
  oprot_->writeMessageBegin("ReleaseSnapshot", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_ReleaseSnapshot_pargs args;
  args.dbhandle = &dbhandle;
  args.snapshot = &snapshot;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes39 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.ReleaseSnapshot", _bytes39);
  return;
}

Code DBClient::recv_ReleaseSnapshot()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.ReleaseSnapshot");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("ReleaseSnapshot") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_ReleaseSnapshot_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.ReleaseSnapshot", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "ReleaseSnapshot failed: unknown result");
}

Code DBClient::CompactRange(const DBHandle& dbhandle, const Slice& start, const Slice& endhere)
{
  folly::ScopeGuard g = folly::makeGuard([&] { this->clearClientContextStack(); });
  this->generateClientContextStack("DB.CompactRange", NULL);

  try {
    send_CompactRange(dbhandle, start, endhere);
    return recv_CompactRange();
  } catch(apache::thrift::transport::TTransportException& ex) {
    this->handlerError(this->getClientContextStack(), "DB.CompactRange");
    iprot_->getTransport()->close();
    oprot_->getTransport()->close();
    throw;
  } catch(apache::thrift::TApplicationException& ex) {
    if (ex.getType() == apache::thrift::TApplicationException::BAD_SEQUENCE_ID) {
      this->handlerError(this->getClientContextStack(), "DB.CompactRange");
      iprot_->getTransport()->close();
      oprot_->getTransport()->close();
    }
    throw;
  }
}

void DBClient::send_CompactRange(const DBHandle& dbhandle, const Slice& start, const Slice& endhere)
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  this->preWrite(ctx, "DB.CompactRange");
  oprot_->writeMessageBegin("CompactRange", apache::thrift::protocol::T_CALL, getNextSendSequenceId());

  DB_CompactRange_pargs args;
  args.dbhandle = &dbhandle;
  args.start = &start;
  args.endhere = &endhere;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  uint32_t _bytes40 = oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
  this->postWrite(ctx, "DB.CompactRange", _bytes40);
  return;
}

Code DBClient::recv_CompactRange()
{
  apache::thrift::ContextStack* ctx = this->getClientContextStack();
  uint32_t bytes;
  int32_t rseqid = 0;
  int32_t eseqid = getNextRecvSequenceId();
  std::string fname;
  apache::thrift::protocol::TMessageType mtype;
  this->preRead(ctx, "DB.CompactRange");

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (this->checkSeqid_ && rseqid != eseqid) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::BAD_SEQUENCE_ID);
  }
  if (mtype == apache::thrift::protocol::T_EXCEPTION) {
    apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != apache::thrift::protocol::T_REPLY) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("CompactRange") != 0) {
    iprot_->skip(apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Code _return;
  DB_CompactRange_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  bytes = iprot_->getTransport()->readEnd();
  this->postRead(ctx, "DB.CompactRange", bytes);

  if (result.__isset.success) {
    return _return;
  }
  throw apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, "CompactRange failed: unknown result");
}

bool DBProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    apache::thrift::TApplicationException x(apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  const ProcessFunction& pf = pfn->second;
  (this->*pf)(seqid, iprot, oprot, connectionContext);
  return true;
}

void DBProcessor::process_Open(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Open", connectionContext));

  this->preRead(ctx.get(), "DB.Open");
  DB_Open_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Open", bytes);

  DB_Open_result result;
  try {
    iface_->Open(result.success, args.dbname, args.dboptions);
    result.__isset.success = true;
  } catch (LeveldbException &se) {
    result.se = se;
    result.__isset.se = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Open");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Open", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Open");
  oprot->writeMessageBegin("Open", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Open", bytes);

}

void DBProcessor::process_Close(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Close", connectionContext));

  this->preRead(ctx.get(), "DB.Close");
  DB_Close_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Close", bytes);

  DB_Close_result result;
  try {
    result.success = iface_->Close(args.dbhandle, args.dbname);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Close");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Close", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Close");
  oprot->writeMessageBegin("Close", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Close", bytes);

}

void DBProcessor::process_Put(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Put", connectionContext));

  this->preRead(ctx.get(), "DB.Put");
  DB_Put_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Put", bytes);

  DB_Put_result result;
  try {
    result.success = iface_->Put(args.dbhandle, args.keyvalue, args.options);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Put");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Put", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Put");
  oprot->writeMessageBegin("Put", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Put", bytes);

}

void DBProcessor::process_Delete(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Delete", connectionContext));

  this->preRead(ctx.get(), "DB.Delete");
  DB_Delete_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Delete", bytes);

  DB_Delete_result result;
  try {
    result.success = iface_->Delete(args.dbhandle, args.key, args.options);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Delete");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Delete", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Delete");
  oprot->writeMessageBegin("Delete", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Delete", bytes);

}

void DBProcessor::process_Write(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Write", connectionContext));

  this->preRead(ctx.get(), "DB.Write");
  DB_Write_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Write", bytes);

  DB_Write_result result;
  try {
    result.success = iface_->Write(args.dbhandle, args.batch, args.options);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Write");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Write", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Write");
  oprot->writeMessageBegin("Write", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Write", bytes);

}

void DBProcessor::process_Get(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.Get", connectionContext));

  this->preRead(ctx.get(), "DB.Get");
  DB_Get_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.Get", bytes);

  DB_Get_result result;
  try {
    iface_->Get(result.success, args.dbhandle, args.inputkey, args.options);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.Get");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Get", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.Get");
  oprot->writeMessageBegin("Get", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.Get", bytes);

}

void DBProcessor::process_NewIterator(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.NewIterator", connectionContext));

  this->preRead(ctx.get(), "DB.NewIterator");
  DB_NewIterator_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.NewIterator", bytes);

  DB_NewIterator_result result;
  try {
    iface_->NewIterator(result.success, args.dbhandle, args.options, args.iteratorType, args.target);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.NewIterator");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("NewIterator", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.NewIterator");
  oprot->writeMessageBegin("NewIterator", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.NewIterator", bytes);

}

void DBProcessor::process_DeleteIterator(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.DeleteIterator", connectionContext));

  this->preRead(ctx.get(), "DB.DeleteIterator");
  DB_DeleteIterator_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.DeleteIterator", bytes);

  DB_DeleteIterator_result result;
  try {
    result.success = iface_->DeleteIterator(args.dbhandle, args.iterator);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.DeleteIterator");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DeleteIterator", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.DeleteIterator");
  oprot->writeMessageBegin("DeleteIterator", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.DeleteIterator", bytes);

}

void DBProcessor::process_GetNext(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.GetNext", connectionContext));

  this->preRead(ctx.get(), "DB.GetNext");
  DB_GetNext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.GetNext", bytes);

  DB_GetNext_result result;
  try {
    iface_->GetNext(result.success, args.dbhandle, args.iterator);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.GetNext");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetNext", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.GetNext");
  oprot->writeMessageBegin("GetNext", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.GetNext", bytes);

}

void DBProcessor::process_GetPrev(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.GetPrev", connectionContext));

  this->preRead(ctx.get(), "DB.GetPrev");
  DB_GetPrev_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.GetPrev", bytes);

  DB_GetPrev_result result;
  try {
    iface_->GetPrev(result.success, args.dbhandle, args.iterator);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.GetPrev");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetPrev", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.GetPrev");
  oprot->writeMessageBegin("GetPrev", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.GetPrev", bytes);

}

void DBProcessor::process_GetSnapshot(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.GetSnapshot", connectionContext));

  this->preRead(ctx.get(), "DB.GetSnapshot");
  DB_GetSnapshot_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.GetSnapshot", bytes);

  DB_GetSnapshot_result result;
  try {
    iface_->GetSnapshot(result.success, args.dbhandle);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.GetSnapshot");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetSnapshot", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.GetSnapshot");
  oprot->writeMessageBegin("GetSnapshot", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.GetSnapshot", bytes);

}

void DBProcessor::process_ReleaseSnapshot(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.ReleaseSnapshot", connectionContext));

  this->preRead(ctx.get(), "DB.ReleaseSnapshot");
  DB_ReleaseSnapshot_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.ReleaseSnapshot", bytes);

  DB_ReleaseSnapshot_result result;
  try {
    result.success = iface_->ReleaseSnapshot(args.dbhandle, args.snapshot);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.ReleaseSnapshot");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ReleaseSnapshot", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.ReleaseSnapshot");
  oprot->writeMessageBegin("ReleaseSnapshot", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.ReleaseSnapshot", bytes);

}

void DBProcessor::process_CompactRange(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext)
{
  std::unique_ptr<apache::thrift::ContextStack> ctx(this->getContextStack("DB.CompactRange", connectionContext));

  this->preRead(ctx.get(), "DB.CompactRange");
  DB_CompactRange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  this->postRead(ctx.get(), "DB.CompactRange", bytes);

  DB_CompactRange_result result;
  try {
    result.success = iface_->CompactRange(args.dbhandle, args.start, args.endhere);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    this->handlerError(ctx.get(), "DB.CompactRange");


    apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CompactRange", apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  this->preWrite(ctx.get(), "DB.CompactRange");
  oprot->writeMessageBegin("CompactRange", apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  this->postWrite(ctx.get(), "DB.CompactRange", bytes);

}

::boost::shared_ptr< ::apache::thrift::TProcessor > DBProcessorFactory::getProcessor(::apache::thrift::server::TConnectionContext* ctx) {
  ::apache::thrift::ReleaseHandler< DBIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< DBIf > handler(handlerFactory_->getHandler(ctx), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new DBProcessor(handler));
  return processor;
}
} // namespace

