/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated SignedSource<<b50937b866513442f6f2690c8af84db0>>
 */
#ifndef reflection_TYPES_H
#define reflection_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>


#include <unordered_map>
#include <boost/interprocess/containers/flat_map.hpp>

namespace apache { namespace thrift { namespace reflection {

enum Type {
  TYPE_VOID = 0,
  TYPE_STRING = 1,
  TYPE_BOOL = 2,
  TYPE_BYTE = 3,
  TYPE_I16 = 4,
  TYPE_I32 = 5,
  TYPE_I64 = 6,
  TYPE_DOUBLE = 7,
  TYPE_ENUM = 8,
  TYPE_LIST = 9,
  TYPE_SET = 10,
  TYPE_MAP = 11,
  TYPE_STRUCT = 12,
  TYPE_SERVICE = 13,
  TYPE_PROGRAM = 14
};

extern const std::map<int, const char*> _Type_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _Type_NAMES_TO_VALUES;

class StructField {
 public:

  StructField() : isRequired(0), type(0), name("") {
  }

  StructField(const StructField&) = default;
  StructField& operator=(const StructField&) = default;
  StructField(StructField&&) = default;
  StructField& operator=(StructField&&) = default;

  void __clear() {
    isRequired = 0;
    type = 0;
    name = "";
    annotations.clear();
    __isset.__clear();
  }

  virtual ~StructField() throw() {}

  bool isRequired;
  int64_t type;
  std::string name;
  boost::container::flat_map<std::string, std::string> annotations;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      isRequired = false;
      type = false;
      name = false;
      annotations = false;
    }
    bool isRequired;
    bool type;
    bool name;
    bool annotations;
  } __isset;

  bool operator == (const StructField & rhs) const
  {
    if (!(this->isRequired == rhs.isRequired))
      return false;
    if (!(this->type == rhs.type))
      return false;
    if (!(this->name == rhs.name))
      return false;
    if (__isset.annotations != rhs.__isset.annotations)
      return false;
    else if (__isset.annotations && !(annotations == rhs.annotations))
      return false;
    return true;
  }
  bool operator != (const StructField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructField & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class StructField;
void swap(StructField &a, StructField &b);

class DataType {
 public:

  DataType() : name(""), mapKeyType(0), valueType(0) {
  }

  DataType(const DataType&) = default;
  DataType& operator=(const DataType&) = default;
  DataType(DataType&&) = default;
  DataType& operator=(DataType&&) = default;

  void __clear() {
    name = "";
    fields.clear();
    mapKeyType = 0;
    valueType = 0;
    enumValues.clear();
    __isset.__clear();
  }

  virtual ~DataType() throw() {}

  std::string name;
  boost::container::flat_map<int16_t, StructField> fields;
  int64_t mapKeyType;
  int64_t valueType;
  boost::container::flat_map<std::string, int32_t> enumValues;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      name = false;
      fields = false;
      mapKeyType = false;
      valueType = false;
      enumValues = false;
    }
    bool name;
    bool fields;
    bool mapKeyType;
    bool valueType;
    bool enumValues;
  } __isset;

  bool operator == (const DataType & rhs) const
  {
    if (!(this->name == rhs.name))
      return false;
    if (__isset.fields != rhs.__isset.fields)
      return false;
    else if (__isset.fields && !(fields == rhs.fields))
      return false;
    if (__isset.mapKeyType != rhs.__isset.mapKeyType)
      return false;
    else if (__isset.mapKeyType && !(mapKeyType == rhs.mapKeyType))
      return false;
    if (__isset.valueType != rhs.__isset.valueType)
      return false;
    else if (__isset.valueType && !(valueType == rhs.valueType))
      return false;
    if (__isset.enumValues != rhs.__isset.enumValues)
      return false;
    else if (__isset.enumValues && !(enumValues == rhs.enumValues))
      return false;
    return true;
  }
  bool operator != (const DataType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataType & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class DataType;
void swap(DataType &a, DataType &b);

class Schema {
 public:

  Schema() {
  }

  Schema(const Schema&) = default;
  Schema& operator=(const Schema&) = default;
  Schema(Schema&&) = default;
  Schema& operator=(Schema&&) = default;

  void __clear() {
    dataTypes.clear();
    names.clear();
    __isset.__clear();
  }

  virtual ~Schema() throw() {}

  std::unordered_map<int64_t, DataType> dataTypes;
  std::unordered_map<std::string, int64_t> names;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      dataTypes = false;
      names = false;
    }
    bool dataTypes;
    bool names;
  } __isset;

  bool operator == (const Schema & rhs) const
  {
    if (!(this->dataTypes == rhs.dataTypes))
      return false;
    if (!(this->names == rhs.names))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Schema;
void swap(Schema &a, Schema &b);

}}} // namespace

#endif
